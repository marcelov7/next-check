
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Teste` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Teste
 * 
 */
export type TesteModel = runtime.Types.Result.DefaultSelection<Prisma.$TestePayload>

export type AggregateTeste = {
  _count: TesteCountAggregateOutputType | null
  _avg: TesteAvgAggregateOutputType | null
  _sum: TesteSumAggregateOutputType | null
  _min: TesteMinAggregateOutputType | null
  _max: TesteMaxAggregateOutputType | null
}

export type TesteAvgAggregateOutputType = {
  id: number | null
  paradaId: number | null
  equipamentoId: number | null
}

export type TesteSumAggregateOutputType = {
  id: number | null
  paradaId: number | null
  equipamentoId: number | null
}

export type TesteMinAggregateOutputType = {
  id: number | null
  paradaId: number | null
  equipamentoId: number | null
  status: $Enums.TesteStatus | null
  observacoes: string | null
  problemaDescricao: string | null
  dataTeste: Date | null
  testadoPor: string | null
  naoAplica: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type TesteMaxAggregateOutputType = {
  id: number | null
  paradaId: number | null
  equipamentoId: number | null
  status: $Enums.TesteStatus | null
  observacoes: string | null
  problemaDescricao: string | null
  dataTeste: Date | null
  testadoPor: string | null
  naoAplica: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type TesteCountAggregateOutputType = {
  id: number
  paradaId: number
  equipamentoId: number
  status: number
  observacoes: number
  problemaDescricao: number
  dataTeste: number
  testadoPor: number
  naoAplica: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type TesteAvgAggregateInputType = {
  id?: true
  paradaId?: true
  equipamentoId?: true
}

export type TesteSumAggregateInputType = {
  id?: true
  paradaId?: true
  equipamentoId?: true
}

export type TesteMinAggregateInputType = {
  id?: true
  paradaId?: true
  equipamentoId?: true
  status?: true
  observacoes?: true
  problemaDescricao?: true
  dataTeste?: true
  testadoPor?: true
  naoAplica?: true
  createdAt?: true
  updatedAt?: true
}

export type TesteMaxAggregateInputType = {
  id?: true
  paradaId?: true
  equipamentoId?: true
  status?: true
  observacoes?: true
  problemaDescricao?: true
  dataTeste?: true
  testadoPor?: true
  naoAplica?: true
  createdAt?: true
  updatedAt?: true
}

export type TesteCountAggregateInputType = {
  id?: true
  paradaId?: true
  equipamentoId?: true
  status?: true
  observacoes?: true
  problemaDescricao?: true
  dataTeste?: true
  testadoPor?: true
  naoAplica?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type TesteAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Teste to aggregate.
   */
  where?: Prisma.TesteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Testes to fetch.
   */
  orderBy?: Prisma.TesteOrderByWithRelationInput | Prisma.TesteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.TesteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Testes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Testes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Testes
  **/
  _count?: true | TesteCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: TesteAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: TesteSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: TesteMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: TesteMaxAggregateInputType
}

export type GetTesteAggregateType<T extends TesteAggregateArgs> = {
      [P in keyof T & keyof AggregateTeste]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateTeste[P]>
    : Prisma.GetScalarType<T[P], AggregateTeste[P]>
}




export type TesteGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.TesteWhereInput
  orderBy?: Prisma.TesteOrderByWithAggregationInput | Prisma.TesteOrderByWithAggregationInput[]
  by: Prisma.TesteScalarFieldEnum[] | Prisma.TesteScalarFieldEnum
  having?: Prisma.TesteScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: TesteCountAggregateInputType | true
  _avg?: TesteAvgAggregateInputType
  _sum?: TesteSumAggregateInputType
  _min?: TesteMinAggregateInputType
  _max?: TesteMaxAggregateInputType
}

export type TesteGroupByOutputType = {
  id: number
  paradaId: number
  equipamentoId: number
  status: $Enums.TesteStatus
  observacoes: string | null
  problemaDescricao: string | null
  dataTeste: Date | null
  testadoPor: string | null
  naoAplica: boolean
  createdAt: Date
  updatedAt: Date
  _count: TesteCountAggregateOutputType | null
  _avg: TesteAvgAggregateOutputType | null
  _sum: TesteSumAggregateOutputType | null
  _min: TesteMinAggregateOutputType | null
  _max: TesteMaxAggregateOutputType | null
}

type GetTesteGroupByPayload<T extends TesteGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<TesteGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof TesteGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], TesteGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], TesteGroupByOutputType[P]>
      }
    >
  >



export type TesteWhereInput = {
  AND?: Prisma.TesteWhereInput | Prisma.TesteWhereInput[]
  OR?: Prisma.TesteWhereInput[]
  NOT?: Prisma.TesteWhereInput | Prisma.TesteWhereInput[]
  id?: Prisma.IntFilter<"Teste"> | number
  paradaId?: Prisma.IntFilter<"Teste"> | number
  equipamentoId?: Prisma.IntFilter<"Teste"> | number
  status?: Prisma.EnumTesteStatusFilter<"Teste"> | $Enums.TesteStatus
  observacoes?: Prisma.StringNullableFilter<"Teste"> | string | null
  problemaDescricao?: Prisma.StringNullableFilter<"Teste"> | string | null
  dataTeste?: Prisma.DateTimeNullableFilter<"Teste"> | Date | string | null
  testadoPor?: Prisma.StringNullableFilter<"Teste"> | string | null
  naoAplica?: Prisma.BoolFilter<"Teste"> | boolean
  createdAt?: Prisma.DateTimeFilter<"Teste"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Teste"> | Date | string
  parada?: Prisma.XOR<Prisma.ParadaScalarRelationFilter, Prisma.ParadaWhereInput>
  equipamento?: Prisma.XOR<Prisma.EquipamentoScalarRelationFilter, Prisma.EquipamentoWhereInput>
}

export type TesteOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  paradaId?: Prisma.SortOrder
  equipamentoId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  observacoes?: Prisma.SortOrderInput | Prisma.SortOrder
  problemaDescricao?: Prisma.SortOrderInput | Prisma.SortOrder
  dataTeste?: Prisma.SortOrderInput | Prisma.SortOrder
  testadoPor?: Prisma.SortOrderInput | Prisma.SortOrder
  naoAplica?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  parada?: Prisma.ParadaOrderByWithRelationInput
  equipamento?: Prisma.EquipamentoOrderByWithRelationInput
  _relevance?: Prisma.TesteOrderByRelevanceInput
}

export type TesteWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  AND?: Prisma.TesteWhereInput | Prisma.TesteWhereInput[]
  OR?: Prisma.TesteWhereInput[]
  NOT?: Prisma.TesteWhereInput | Prisma.TesteWhereInput[]
  paradaId?: Prisma.IntFilter<"Teste"> | number
  equipamentoId?: Prisma.IntFilter<"Teste"> | number
  status?: Prisma.EnumTesteStatusFilter<"Teste"> | $Enums.TesteStatus
  observacoes?: Prisma.StringNullableFilter<"Teste"> | string | null
  problemaDescricao?: Prisma.StringNullableFilter<"Teste"> | string | null
  dataTeste?: Prisma.DateTimeNullableFilter<"Teste"> | Date | string | null
  testadoPor?: Prisma.StringNullableFilter<"Teste"> | string | null
  naoAplica?: Prisma.BoolFilter<"Teste"> | boolean
  createdAt?: Prisma.DateTimeFilter<"Teste"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Teste"> | Date | string
  parada?: Prisma.XOR<Prisma.ParadaScalarRelationFilter, Prisma.ParadaWhereInput>
  equipamento?: Prisma.XOR<Prisma.EquipamentoScalarRelationFilter, Prisma.EquipamentoWhereInput>
}, "id">

export type TesteOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  paradaId?: Prisma.SortOrder
  equipamentoId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  observacoes?: Prisma.SortOrderInput | Prisma.SortOrder
  problemaDescricao?: Prisma.SortOrderInput | Prisma.SortOrder
  dataTeste?: Prisma.SortOrderInput | Prisma.SortOrder
  testadoPor?: Prisma.SortOrderInput | Prisma.SortOrder
  naoAplica?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.TesteCountOrderByAggregateInput
  _avg?: Prisma.TesteAvgOrderByAggregateInput
  _max?: Prisma.TesteMaxOrderByAggregateInput
  _min?: Prisma.TesteMinOrderByAggregateInput
  _sum?: Prisma.TesteSumOrderByAggregateInput
}

export type TesteScalarWhereWithAggregatesInput = {
  AND?: Prisma.TesteScalarWhereWithAggregatesInput | Prisma.TesteScalarWhereWithAggregatesInput[]
  OR?: Prisma.TesteScalarWhereWithAggregatesInput[]
  NOT?: Prisma.TesteScalarWhereWithAggregatesInput | Prisma.TesteScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"Teste"> | number
  paradaId?: Prisma.IntWithAggregatesFilter<"Teste"> | number
  equipamentoId?: Prisma.IntWithAggregatesFilter<"Teste"> | number
  status?: Prisma.EnumTesteStatusWithAggregatesFilter<"Teste"> | $Enums.TesteStatus
  observacoes?: Prisma.StringNullableWithAggregatesFilter<"Teste"> | string | null
  problemaDescricao?: Prisma.StringNullableWithAggregatesFilter<"Teste"> | string | null
  dataTeste?: Prisma.DateTimeNullableWithAggregatesFilter<"Teste"> | Date | string | null
  testadoPor?: Prisma.StringNullableWithAggregatesFilter<"Teste"> | string | null
  naoAplica?: Prisma.BoolWithAggregatesFilter<"Teste"> | boolean
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Teste"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Teste"> | Date | string
}

export type TesteCreateInput = {
  status?: $Enums.TesteStatus
  observacoes?: string | null
  problemaDescricao?: string | null
  dataTeste?: Date | string | null
  testadoPor?: string | null
  naoAplica?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  parada: Prisma.ParadaCreateNestedOneWithoutTestesInput
  equipamento: Prisma.EquipamentoCreateNestedOneWithoutTestesInput
}

export type TesteUncheckedCreateInput = {
  id?: number
  paradaId: number
  equipamentoId: number
  status?: $Enums.TesteStatus
  observacoes?: string | null
  problemaDescricao?: string | null
  dataTeste?: Date | string | null
  testadoPor?: string | null
  naoAplica?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TesteUpdateInput = {
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  parada?: Prisma.ParadaUpdateOneRequiredWithoutTestesNestedInput
  equipamento?: Prisma.EquipamentoUpdateOneRequiredWithoutTestesNestedInput
}

export type TesteUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  paradaId?: Prisma.IntFieldUpdateOperationsInput | number
  equipamentoId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TesteCreateManyInput = {
  id?: number
  paradaId: number
  equipamentoId: number
  status?: $Enums.TesteStatus
  observacoes?: string | null
  problemaDescricao?: string | null
  dataTeste?: Date | string | null
  testadoPor?: string | null
  naoAplica?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TesteUpdateManyMutationInput = {
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TesteUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  paradaId?: Prisma.IntFieldUpdateOperationsInput | number
  equipamentoId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TesteListRelationFilter = {
  every?: Prisma.TesteWhereInput
  some?: Prisma.TesteWhereInput
  none?: Prisma.TesteWhereInput
}

export type TesteOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type TesteOrderByRelevanceInput = {
  fields: Prisma.TesteOrderByRelevanceFieldEnum | Prisma.TesteOrderByRelevanceFieldEnum[]
  sort: Prisma.SortOrder
  search: string
}

export type TesteCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  paradaId?: Prisma.SortOrder
  equipamentoId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  observacoes?: Prisma.SortOrder
  problemaDescricao?: Prisma.SortOrder
  dataTeste?: Prisma.SortOrder
  testadoPor?: Prisma.SortOrder
  naoAplica?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type TesteAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  paradaId?: Prisma.SortOrder
  equipamentoId?: Prisma.SortOrder
}

export type TesteMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  paradaId?: Prisma.SortOrder
  equipamentoId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  observacoes?: Prisma.SortOrder
  problemaDescricao?: Prisma.SortOrder
  dataTeste?: Prisma.SortOrder
  testadoPor?: Prisma.SortOrder
  naoAplica?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type TesteMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  paradaId?: Prisma.SortOrder
  equipamentoId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  observacoes?: Prisma.SortOrder
  problemaDescricao?: Prisma.SortOrder
  dataTeste?: Prisma.SortOrder
  testadoPor?: Prisma.SortOrder
  naoAplica?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type TesteSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  paradaId?: Prisma.SortOrder
  equipamentoId?: Prisma.SortOrder
}

export type TesteCreateNestedManyWithoutEquipamentoInput = {
  create?: Prisma.XOR<Prisma.TesteCreateWithoutEquipamentoInput, Prisma.TesteUncheckedCreateWithoutEquipamentoInput> | Prisma.TesteCreateWithoutEquipamentoInput[] | Prisma.TesteUncheckedCreateWithoutEquipamentoInput[]
  connectOrCreate?: Prisma.TesteCreateOrConnectWithoutEquipamentoInput | Prisma.TesteCreateOrConnectWithoutEquipamentoInput[]
  createMany?: Prisma.TesteCreateManyEquipamentoInputEnvelope
  connect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
}

export type TesteUncheckedCreateNestedManyWithoutEquipamentoInput = {
  create?: Prisma.XOR<Prisma.TesteCreateWithoutEquipamentoInput, Prisma.TesteUncheckedCreateWithoutEquipamentoInput> | Prisma.TesteCreateWithoutEquipamentoInput[] | Prisma.TesteUncheckedCreateWithoutEquipamentoInput[]
  connectOrCreate?: Prisma.TesteCreateOrConnectWithoutEquipamentoInput | Prisma.TesteCreateOrConnectWithoutEquipamentoInput[]
  createMany?: Prisma.TesteCreateManyEquipamentoInputEnvelope
  connect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
}

export type TesteUpdateManyWithoutEquipamentoNestedInput = {
  create?: Prisma.XOR<Prisma.TesteCreateWithoutEquipamentoInput, Prisma.TesteUncheckedCreateWithoutEquipamentoInput> | Prisma.TesteCreateWithoutEquipamentoInput[] | Prisma.TesteUncheckedCreateWithoutEquipamentoInput[]
  connectOrCreate?: Prisma.TesteCreateOrConnectWithoutEquipamentoInput | Prisma.TesteCreateOrConnectWithoutEquipamentoInput[]
  upsert?: Prisma.TesteUpsertWithWhereUniqueWithoutEquipamentoInput | Prisma.TesteUpsertWithWhereUniqueWithoutEquipamentoInput[]
  createMany?: Prisma.TesteCreateManyEquipamentoInputEnvelope
  set?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  disconnect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  delete?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  connect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  update?: Prisma.TesteUpdateWithWhereUniqueWithoutEquipamentoInput | Prisma.TesteUpdateWithWhereUniqueWithoutEquipamentoInput[]
  updateMany?: Prisma.TesteUpdateManyWithWhereWithoutEquipamentoInput | Prisma.TesteUpdateManyWithWhereWithoutEquipamentoInput[]
  deleteMany?: Prisma.TesteScalarWhereInput | Prisma.TesteScalarWhereInput[]
}

export type TesteUncheckedUpdateManyWithoutEquipamentoNestedInput = {
  create?: Prisma.XOR<Prisma.TesteCreateWithoutEquipamentoInput, Prisma.TesteUncheckedCreateWithoutEquipamentoInput> | Prisma.TesteCreateWithoutEquipamentoInput[] | Prisma.TesteUncheckedCreateWithoutEquipamentoInput[]
  connectOrCreate?: Prisma.TesteCreateOrConnectWithoutEquipamentoInput | Prisma.TesteCreateOrConnectWithoutEquipamentoInput[]
  upsert?: Prisma.TesteUpsertWithWhereUniqueWithoutEquipamentoInput | Prisma.TesteUpsertWithWhereUniqueWithoutEquipamentoInput[]
  createMany?: Prisma.TesteCreateManyEquipamentoInputEnvelope
  set?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  disconnect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  delete?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  connect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  update?: Prisma.TesteUpdateWithWhereUniqueWithoutEquipamentoInput | Prisma.TesteUpdateWithWhereUniqueWithoutEquipamentoInput[]
  updateMany?: Prisma.TesteUpdateManyWithWhereWithoutEquipamentoInput | Prisma.TesteUpdateManyWithWhereWithoutEquipamentoInput[]
  deleteMany?: Prisma.TesteScalarWhereInput | Prisma.TesteScalarWhereInput[]
}

export type TesteCreateNestedManyWithoutParadaInput = {
  create?: Prisma.XOR<Prisma.TesteCreateWithoutParadaInput, Prisma.TesteUncheckedCreateWithoutParadaInput> | Prisma.TesteCreateWithoutParadaInput[] | Prisma.TesteUncheckedCreateWithoutParadaInput[]
  connectOrCreate?: Prisma.TesteCreateOrConnectWithoutParadaInput | Prisma.TesteCreateOrConnectWithoutParadaInput[]
  createMany?: Prisma.TesteCreateManyParadaInputEnvelope
  connect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
}

export type TesteUncheckedCreateNestedManyWithoutParadaInput = {
  create?: Prisma.XOR<Prisma.TesteCreateWithoutParadaInput, Prisma.TesteUncheckedCreateWithoutParadaInput> | Prisma.TesteCreateWithoutParadaInput[] | Prisma.TesteUncheckedCreateWithoutParadaInput[]
  connectOrCreate?: Prisma.TesteCreateOrConnectWithoutParadaInput | Prisma.TesteCreateOrConnectWithoutParadaInput[]
  createMany?: Prisma.TesteCreateManyParadaInputEnvelope
  connect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
}

export type TesteUpdateManyWithoutParadaNestedInput = {
  create?: Prisma.XOR<Prisma.TesteCreateWithoutParadaInput, Prisma.TesteUncheckedCreateWithoutParadaInput> | Prisma.TesteCreateWithoutParadaInput[] | Prisma.TesteUncheckedCreateWithoutParadaInput[]
  connectOrCreate?: Prisma.TesteCreateOrConnectWithoutParadaInput | Prisma.TesteCreateOrConnectWithoutParadaInput[]
  upsert?: Prisma.TesteUpsertWithWhereUniqueWithoutParadaInput | Prisma.TesteUpsertWithWhereUniqueWithoutParadaInput[]
  createMany?: Prisma.TesteCreateManyParadaInputEnvelope
  set?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  disconnect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  delete?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  connect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  update?: Prisma.TesteUpdateWithWhereUniqueWithoutParadaInput | Prisma.TesteUpdateWithWhereUniqueWithoutParadaInput[]
  updateMany?: Prisma.TesteUpdateManyWithWhereWithoutParadaInput | Prisma.TesteUpdateManyWithWhereWithoutParadaInput[]
  deleteMany?: Prisma.TesteScalarWhereInput | Prisma.TesteScalarWhereInput[]
}

export type TesteUncheckedUpdateManyWithoutParadaNestedInput = {
  create?: Prisma.XOR<Prisma.TesteCreateWithoutParadaInput, Prisma.TesteUncheckedCreateWithoutParadaInput> | Prisma.TesteCreateWithoutParadaInput[] | Prisma.TesteUncheckedCreateWithoutParadaInput[]
  connectOrCreate?: Prisma.TesteCreateOrConnectWithoutParadaInput | Prisma.TesteCreateOrConnectWithoutParadaInput[]
  upsert?: Prisma.TesteUpsertWithWhereUniqueWithoutParadaInput | Prisma.TesteUpsertWithWhereUniqueWithoutParadaInput[]
  createMany?: Prisma.TesteCreateManyParadaInputEnvelope
  set?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  disconnect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  delete?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  connect?: Prisma.TesteWhereUniqueInput | Prisma.TesteWhereUniqueInput[]
  update?: Prisma.TesteUpdateWithWhereUniqueWithoutParadaInput | Prisma.TesteUpdateWithWhereUniqueWithoutParadaInput[]
  updateMany?: Prisma.TesteUpdateManyWithWhereWithoutParadaInput | Prisma.TesteUpdateManyWithWhereWithoutParadaInput[]
  deleteMany?: Prisma.TesteScalarWhereInput | Prisma.TesteScalarWhereInput[]
}

export type EnumTesteStatusFieldUpdateOperationsInput = {
  set?: $Enums.TesteStatus
}

export type TesteCreateWithoutEquipamentoInput = {
  status?: $Enums.TesteStatus
  observacoes?: string | null
  problemaDescricao?: string | null
  dataTeste?: Date | string | null
  testadoPor?: string | null
  naoAplica?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  parada: Prisma.ParadaCreateNestedOneWithoutTestesInput
}

export type TesteUncheckedCreateWithoutEquipamentoInput = {
  id?: number
  paradaId: number
  status?: $Enums.TesteStatus
  observacoes?: string | null
  problemaDescricao?: string | null
  dataTeste?: Date | string | null
  testadoPor?: string | null
  naoAplica?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TesteCreateOrConnectWithoutEquipamentoInput = {
  where: Prisma.TesteWhereUniqueInput
  create: Prisma.XOR<Prisma.TesteCreateWithoutEquipamentoInput, Prisma.TesteUncheckedCreateWithoutEquipamentoInput>
}

export type TesteCreateManyEquipamentoInputEnvelope = {
  data: Prisma.TesteCreateManyEquipamentoInput | Prisma.TesteCreateManyEquipamentoInput[]
  skipDuplicates?: boolean
}

export type TesteUpsertWithWhereUniqueWithoutEquipamentoInput = {
  where: Prisma.TesteWhereUniqueInput
  update: Prisma.XOR<Prisma.TesteUpdateWithoutEquipamentoInput, Prisma.TesteUncheckedUpdateWithoutEquipamentoInput>
  create: Prisma.XOR<Prisma.TesteCreateWithoutEquipamentoInput, Prisma.TesteUncheckedCreateWithoutEquipamentoInput>
}

export type TesteUpdateWithWhereUniqueWithoutEquipamentoInput = {
  where: Prisma.TesteWhereUniqueInput
  data: Prisma.XOR<Prisma.TesteUpdateWithoutEquipamentoInput, Prisma.TesteUncheckedUpdateWithoutEquipamentoInput>
}

export type TesteUpdateManyWithWhereWithoutEquipamentoInput = {
  where: Prisma.TesteScalarWhereInput
  data: Prisma.XOR<Prisma.TesteUpdateManyMutationInput, Prisma.TesteUncheckedUpdateManyWithoutEquipamentoInput>
}

export type TesteScalarWhereInput = {
  AND?: Prisma.TesteScalarWhereInput | Prisma.TesteScalarWhereInput[]
  OR?: Prisma.TesteScalarWhereInput[]
  NOT?: Prisma.TesteScalarWhereInput | Prisma.TesteScalarWhereInput[]
  id?: Prisma.IntFilter<"Teste"> | number
  paradaId?: Prisma.IntFilter<"Teste"> | number
  equipamentoId?: Prisma.IntFilter<"Teste"> | number
  status?: Prisma.EnumTesteStatusFilter<"Teste"> | $Enums.TesteStatus
  observacoes?: Prisma.StringNullableFilter<"Teste"> | string | null
  problemaDescricao?: Prisma.StringNullableFilter<"Teste"> | string | null
  dataTeste?: Prisma.DateTimeNullableFilter<"Teste"> | Date | string | null
  testadoPor?: Prisma.StringNullableFilter<"Teste"> | string | null
  naoAplica?: Prisma.BoolFilter<"Teste"> | boolean
  createdAt?: Prisma.DateTimeFilter<"Teste"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Teste"> | Date | string
}

export type TesteCreateWithoutParadaInput = {
  status?: $Enums.TesteStatus
  observacoes?: string | null
  problemaDescricao?: string | null
  dataTeste?: Date | string | null
  testadoPor?: string | null
  naoAplica?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  equipamento: Prisma.EquipamentoCreateNestedOneWithoutTestesInput
}

export type TesteUncheckedCreateWithoutParadaInput = {
  id?: number
  equipamentoId: number
  status?: $Enums.TesteStatus
  observacoes?: string | null
  problemaDescricao?: string | null
  dataTeste?: Date | string | null
  testadoPor?: string | null
  naoAplica?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TesteCreateOrConnectWithoutParadaInput = {
  where: Prisma.TesteWhereUniqueInput
  create: Prisma.XOR<Prisma.TesteCreateWithoutParadaInput, Prisma.TesteUncheckedCreateWithoutParadaInput>
}

export type TesteCreateManyParadaInputEnvelope = {
  data: Prisma.TesteCreateManyParadaInput | Prisma.TesteCreateManyParadaInput[]
  skipDuplicates?: boolean
}

export type TesteUpsertWithWhereUniqueWithoutParadaInput = {
  where: Prisma.TesteWhereUniqueInput
  update: Prisma.XOR<Prisma.TesteUpdateWithoutParadaInput, Prisma.TesteUncheckedUpdateWithoutParadaInput>
  create: Prisma.XOR<Prisma.TesteCreateWithoutParadaInput, Prisma.TesteUncheckedCreateWithoutParadaInput>
}

export type TesteUpdateWithWhereUniqueWithoutParadaInput = {
  where: Prisma.TesteWhereUniqueInput
  data: Prisma.XOR<Prisma.TesteUpdateWithoutParadaInput, Prisma.TesteUncheckedUpdateWithoutParadaInput>
}

export type TesteUpdateManyWithWhereWithoutParadaInput = {
  where: Prisma.TesteScalarWhereInput
  data: Prisma.XOR<Prisma.TesteUpdateManyMutationInput, Prisma.TesteUncheckedUpdateManyWithoutParadaInput>
}

export type TesteCreateManyEquipamentoInput = {
  id?: number
  paradaId: number
  status?: $Enums.TesteStatus
  observacoes?: string | null
  problemaDescricao?: string | null
  dataTeste?: Date | string | null
  testadoPor?: string | null
  naoAplica?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TesteUpdateWithoutEquipamentoInput = {
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  parada?: Prisma.ParadaUpdateOneRequiredWithoutTestesNestedInput
}

export type TesteUncheckedUpdateWithoutEquipamentoInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  paradaId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TesteUncheckedUpdateManyWithoutEquipamentoInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  paradaId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TesteCreateManyParadaInput = {
  id?: number
  equipamentoId: number
  status?: $Enums.TesteStatus
  observacoes?: string | null
  problemaDescricao?: string | null
  dataTeste?: Date | string | null
  testadoPor?: string | null
  naoAplica?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type TesteUpdateWithoutParadaInput = {
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  equipamento?: Prisma.EquipamentoUpdateOneRequiredWithoutTestesNestedInput
}

export type TesteUncheckedUpdateWithoutParadaInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  equipamentoId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type TesteUncheckedUpdateManyWithoutParadaInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  equipamentoId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.EnumTesteStatusFieldUpdateOperationsInput | $Enums.TesteStatus
  observacoes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  problemaDescricao?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  dataTeste?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  testadoPor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  naoAplica?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type TesteSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  paradaId?: boolean
  equipamentoId?: boolean
  status?: boolean
  observacoes?: boolean
  problemaDescricao?: boolean
  dataTeste?: boolean
  testadoPor?: boolean
  naoAplica?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  parada?: boolean | Prisma.ParadaDefaultArgs<ExtArgs>
  equipamento?: boolean | Prisma.EquipamentoDefaultArgs<ExtArgs>
}, ExtArgs["result"]["teste"]>



export type TesteSelectScalar = {
  id?: boolean
  paradaId?: boolean
  equipamentoId?: boolean
  status?: boolean
  observacoes?: boolean
  problemaDescricao?: boolean
  dataTeste?: boolean
  testadoPor?: boolean
  naoAplica?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type TesteOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "paradaId" | "equipamentoId" | "status" | "observacoes" | "problemaDescricao" | "dataTeste" | "testadoPor" | "naoAplica" | "createdAt" | "updatedAt", ExtArgs["result"]["teste"]>
export type TesteInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  parada?: boolean | Prisma.ParadaDefaultArgs<ExtArgs>
  equipamento?: boolean | Prisma.EquipamentoDefaultArgs<ExtArgs>
}

export type $TestePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Teste"
  objects: {
    parada: Prisma.$ParadaPayload<ExtArgs>
    equipamento: Prisma.$EquipamentoPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    paradaId: number
    equipamentoId: number
    status: $Enums.TesteStatus
    observacoes: string | null
    problemaDescricao: string | null
    dataTeste: Date | null
    testadoPor: string | null
    naoAplica: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["teste"]>
  composites: {}
}

export type TesteGetPayload<S extends boolean | null | undefined | TesteDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$TestePayload, S>

export type TesteCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<TesteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TesteCountAggregateInputType | true
  }

export interface TesteDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teste'], meta: { name: 'Teste' } }
  /**
   * Find zero or one Teste that matches the filter.
   * @param {TesteFindUniqueArgs} args - Arguments to find a Teste
   * @example
   * // Get one Teste
   * const teste = await prisma.teste.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends TesteFindUniqueArgs>(args: Prisma.SelectSubset<T, TesteFindUniqueArgs<ExtArgs>>): Prisma.Prisma__TesteClient<runtime.Types.Result.GetResult<Prisma.$TestePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Teste that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {TesteFindUniqueOrThrowArgs} args - Arguments to find a Teste
   * @example
   * // Get one Teste
   * const teste = await prisma.teste.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends TesteFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, TesteFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__TesteClient<runtime.Types.Result.GetResult<Prisma.$TestePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Teste that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TesteFindFirstArgs} args - Arguments to find a Teste
   * @example
   * // Get one Teste
   * const teste = await prisma.teste.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends TesteFindFirstArgs>(args?: Prisma.SelectSubset<T, TesteFindFirstArgs<ExtArgs>>): Prisma.Prisma__TesteClient<runtime.Types.Result.GetResult<Prisma.$TestePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Teste that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TesteFindFirstOrThrowArgs} args - Arguments to find a Teste
   * @example
   * // Get one Teste
   * const teste = await prisma.teste.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends TesteFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, TesteFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__TesteClient<runtime.Types.Result.GetResult<Prisma.$TestePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Testes that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TesteFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Testes
   * const testes = await prisma.teste.findMany()
   * 
   * // Get first 10 Testes
   * const testes = await prisma.teste.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const testeWithIdOnly = await prisma.teste.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends TesteFindManyArgs>(args?: Prisma.SelectSubset<T, TesteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$TestePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Teste.
   * @param {TesteCreateArgs} args - Arguments to create a Teste.
   * @example
   * // Create one Teste
   * const Teste = await prisma.teste.create({
   *   data: {
   *     // ... data to create a Teste
   *   }
   * })
   * 
   */
  create<T extends TesteCreateArgs>(args: Prisma.SelectSubset<T, TesteCreateArgs<ExtArgs>>): Prisma.Prisma__TesteClient<runtime.Types.Result.GetResult<Prisma.$TestePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Testes.
   * @param {TesteCreateManyArgs} args - Arguments to create many Testes.
   * @example
   * // Create many Testes
   * const teste = await prisma.teste.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends TesteCreateManyArgs>(args?: Prisma.SelectSubset<T, TesteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Delete a Teste.
   * @param {TesteDeleteArgs} args - Arguments to delete one Teste.
   * @example
   * // Delete one Teste
   * const Teste = await prisma.teste.delete({
   *   where: {
   *     // ... filter to delete one Teste
   *   }
   * })
   * 
   */
  delete<T extends TesteDeleteArgs>(args: Prisma.SelectSubset<T, TesteDeleteArgs<ExtArgs>>): Prisma.Prisma__TesteClient<runtime.Types.Result.GetResult<Prisma.$TestePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Teste.
   * @param {TesteUpdateArgs} args - Arguments to update one Teste.
   * @example
   * // Update one Teste
   * const teste = await prisma.teste.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends TesteUpdateArgs>(args: Prisma.SelectSubset<T, TesteUpdateArgs<ExtArgs>>): Prisma.Prisma__TesteClient<runtime.Types.Result.GetResult<Prisma.$TestePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Testes.
   * @param {TesteDeleteManyArgs} args - Arguments to filter Testes to delete.
   * @example
   * // Delete a few Testes
   * const { count } = await prisma.teste.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends TesteDeleteManyArgs>(args?: Prisma.SelectSubset<T, TesteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Testes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TesteUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Testes
   * const teste = await prisma.teste.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends TesteUpdateManyArgs>(args: Prisma.SelectSubset<T, TesteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create or update one Teste.
   * @param {TesteUpsertArgs} args - Arguments to update or create a Teste.
   * @example
   * // Update or create a Teste
   * const teste = await prisma.teste.upsert({
   *   create: {
   *     // ... data to create a Teste
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Teste we want to update
   *   }
   * })
   */
  upsert<T extends TesteUpsertArgs>(args: Prisma.SelectSubset<T, TesteUpsertArgs<ExtArgs>>): Prisma.Prisma__TesteClient<runtime.Types.Result.GetResult<Prisma.$TestePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Testes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TesteCountArgs} args - Arguments to filter Testes to count.
   * @example
   * // Count the number of Testes
   * const count = await prisma.teste.count({
   *   where: {
   *     // ... the filter for the Testes we want to count
   *   }
   * })
  **/
  count<T extends TesteCountArgs>(
    args?: Prisma.Subset<T, TesteCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], TesteCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Teste.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TesteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends TesteAggregateArgs>(args: Prisma.Subset<T, TesteAggregateArgs>): Prisma.PrismaPromise<GetTesteAggregateType<T>>

  /**
   * Group by Teste.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TesteGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends TesteGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: TesteGroupByArgs['orderBy'] }
      : { orderBy?: TesteGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, TesteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTesteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Teste model
 */
readonly fields: TesteFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Teste.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__TesteClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  parada<T extends Prisma.ParadaDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ParadaDefaultArgs<ExtArgs>>): Prisma.Prisma__ParadaClient<runtime.Types.Result.GetResult<Prisma.$ParadaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  equipamento<T extends Prisma.EquipamentoDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EquipamentoDefaultArgs<ExtArgs>>): Prisma.Prisma__EquipamentoClient<runtime.Types.Result.GetResult<Prisma.$EquipamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Teste model
 */
export interface TesteFieldRefs {
  readonly id: Prisma.FieldRef<"Teste", 'Int'>
  readonly paradaId: Prisma.FieldRef<"Teste", 'Int'>
  readonly equipamentoId: Prisma.FieldRef<"Teste", 'Int'>
  readonly status: Prisma.FieldRef<"Teste", 'TesteStatus'>
  readonly observacoes: Prisma.FieldRef<"Teste", 'String'>
  readonly problemaDescricao: Prisma.FieldRef<"Teste", 'String'>
  readonly dataTeste: Prisma.FieldRef<"Teste", 'DateTime'>
  readonly testadoPor: Prisma.FieldRef<"Teste", 'String'>
  readonly naoAplica: Prisma.FieldRef<"Teste", 'Boolean'>
  readonly createdAt: Prisma.FieldRef<"Teste", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"Teste", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Teste findUnique
 */
export type TesteFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
  /**
   * Filter, which Teste to fetch.
   */
  where: Prisma.TesteWhereUniqueInput
}

/**
 * Teste findUniqueOrThrow
 */
export type TesteFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
  /**
   * Filter, which Teste to fetch.
   */
  where: Prisma.TesteWhereUniqueInput
}

/**
 * Teste findFirst
 */
export type TesteFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
  /**
   * Filter, which Teste to fetch.
   */
  where?: Prisma.TesteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Testes to fetch.
   */
  orderBy?: Prisma.TesteOrderByWithRelationInput | Prisma.TesteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Testes.
   */
  cursor?: Prisma.TesteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Testes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Testes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Testes.
   */
  distinct?: Prisma.TesteScalarFieldEnum | Prisma.TesteScalarFieldEnum[]
}

/**
 * Teste findFirstOrThrow
 */
export type TesteFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
  /**
   * Filter, which Teste to fetch.
   */
  where?: Prisma.TesteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Testes to fetch.
   */
  orderBy?: Prisma.TesteOrderByWithRelationInput | Prisma.TesteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Testes.
   */
  cursor?: Prisma.TesteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Testes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Testes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Testes.
   */
  distinct?: Prisma.TesteScalarFieldEnum | Prisma.TesteScalarFieldEnum[]
}

/**
 * Teste findMany
 */
export type TesteFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
  /**
   * Filter, which Testes to fetch.
   */
  where?: Prisma.TesteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Testes to fetch.
   */
  orderBy?: Prisma.TesteOrderByWithRelationInput | Prisma.TesteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Testes.
   */
  cursor?: Prisma.TesteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Testes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Testes.
   */
  skip?: number
  distinct?: Prisma.TesteScalarFieldEnum | Prisma.TesteScalarFieldEnum[]
}

/**
 * Teste create
 */
export type TesteCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
  /**
   * The data needed to create a Teste.
   */
  data: Prisma.XOR<Prisma.TesteCreateInput, Prisma.TesteUncheckedCreateInput>
}

/**
 * Teste createMany
 */
export type TesteCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Testes.
   */
  data: Prisma.TesteCreateManyInput | Prisma.TesteCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Teste update
 */
export type TesteUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
  /**
   * The data needed to update a Teste.
   */
  data: Prisma.XOR<Prisma.TesteUpdateInput, Prisma.TesteUncheckedUpdateInput>
  /**
   * Choose, which Teste to update.
   */
  where: Prisma.TesteWhereUniqueInput
}

/**
 * Teste updateMany
 */
export type TesteUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Testes.
   */
  data: Prisma.XOR<Prisma.TesteUpdateManyMutationInput, Prisma.TesteUncheckedUpdateManyInput>
  /**
   * Filter which Testes to update
   */
  where?: Prisma.TesteWhereInput
  /**
   * Limit how many Testes to update.
   */
  limit?: number
}

/**
 * Teste upsert
 */
export type TesteUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
  /**
   * The filter to search for the Teste to update in case it exists.
   */
  where: Prisma.TesteWhereUniqueInput
  /**
   * In case the Teste found by the `where` argument doesn't exist, create a new Teste with this data.
   */
  create: Prisma.XOR<Prisma.TesteCreateInput, Prisma.TesteUncheckedCreateInput>
  /**
   * In case the Teste was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.TesteUpdateInput, Prisma.TesteUncheckedUpdateInput>
}

/**
 * Teste delete
 */
export type TesteDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
  /**
   * Filter which Teste to delete.
   */
  where: Prisma.TesteWhereUniqueInput
}

/**
 * Teste deleteMany
 */
export type TesteDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Testes to delete
   */
  where?: Prisma.TesteWhereInput
  /**
   * Limit how many Testes to delete.
   */
  limit?: number
}

/**
 * Teste without action
 */
export type TesteDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Teste
   */
  select?: Prisma.TesteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Teste
   */
  omit?: Prisma.TesteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TesteInclude<ExtArgs> | null
}
